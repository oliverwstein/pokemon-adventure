// In: build.rs

use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

// Your build script now depends on the schema crate, ron, and postcard.
use schema::{Move, MoveData, PokemonSpecies};
use serde::{Deserialize, Serialize};

// Team data structures for build script
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TeamTemplate {
    id: String,
    name: String,
    description: String,
    pokemon: Vec<PokemonTemplate>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct PokemonTemplate {
    species: schema::Species,
    level: u8,
    moves: Option<Vec<schema::Move>>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // --- Setup ---
    println!("cargo:rerun-if-changed=data");
    let out_dir = env::var("OUT_DIR").unwrap();
    let generated_code_path = Path::new(&out_dir).join("generated_data.rs");
    let mut code_file = fs::File::create(&generated_code_path)?;

    // --- File Header ---
    writeln!(
        code_file,
        "// This file is generated by build.rs - do not edit manually."
    )?;
    writeln!(
        code_file,
        "// It contains functions to load compile-time data from binary files."
    )?;
    writeln!(code_file)?;

    // --- Data Generation ---
    generate_move_data(&out_dir, &mut code_file)?;
    generate_species_data(&out_dir, &mut code_file)?;
    generate_team_data(&out_dir, &mut code_file)?;
    println!(
        "Generated postcard data and loader functions at: {}",
        out_dir
    );
    Ok(())
}

/// Parses move .ron files, serializes them to a postcard binary file,
/// and writes a Rust function that loads this data as a static HashMap.
fn generate_move_data(out_dir: &str, f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=data/moves");
    let data_path = Path::new("data/moves");
    let mut moves_map = HashMap::<Move, MoveData>::new();

    for entry in fs::read_dir(data_path)? {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;
            let move_data: MoveData = ron::from_str(&content)
                .map_err(|e| format!("Failed to parse {:?}: {}", path, e))?;
            // Robustly parse the move name from the data to get the enum variant
            let move_enum_variant: Move = move_data.name.parse().map_err(|e| {
                format!(
                    "Failed to parse move name '{}' in {:?}: {}",
                    move_data.name, path, e
                )
            })?;
            moves_map.insert(move_enum_variant, move_data);
        }
    }

    // Serialize the entire map to a binary file
    let postcard_bytes = postcard::to_allocvec(&moves_map)?;
    let dest_path = Path::new(out_dir).join("compiled_moves.postcard");
    fs::write(dest_path, postcard_bytes)?;

    // Write the Rust function that will load these bytes at compile time
    writeln!(f, "pub fn get_compiled_move_data() -> std::collections::HashMap<schema::Move, schema::MoveData> {{")?;
    writeln!(
        f,
        "    let bytes = include_bytes!(concat!(env!(\"OUT_DIR\"), \"/compiled_moves.postcard\"));"
    )?;
    writeln!(
        f,
        "    postcard::from_bytes(bytes).expect(\"Failed to deserialize move data\")"
    )?;
    writeln!(f, "}}")?;
    writeln!(f)?;
    Ok(())
}

/// Parses species .ron files, serializes them to a postcard binary file,
/// and writes a Rust function that loads this data as a static slice.
fn generate_species_data(
    out_dir: &str,
    f: &mut fs::File,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=data/pokemon");
    let data_path = Path::new("data/pokemon");

    // Dynamically count the number of valid Pokémon .ron files
    let pokemon_count = fs::read_dir(data_path)?
        .filter_map(Result::ok)
        .filter(|entry| entry.path().extension().and_then(|s| s.to_str()) == Some("ron"))
        .count();

    if pokemon_count == 0 {
        writeln!(f, "// No Pokémon data found, generating an empty slice.")?;
        writeln!(
            f,
            "pub fn get_compiled_species_data() -> &'static [Option<schema::PokemonSpecies>] {{"
        )?;
        writeln!(f, "    &[]")?;
        writeln!(f, "}}")?;
        return Ok(());
    }

    // Use a Vec for easier, safer initialization based on the dynamic count
    let mut species_vec: Vec<Option<PokemonSpecies>> = vec![None; pokemon_count];

    for entry in fs::read_dir(data_path)? {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;
            let species_data: PokemonSpecies = ron::from_str(&content)
                .map_err(|e| format!("Failed to parse {:?}: {}", path, e))?;
            let index = species_data.pokedex_number as usize - 1;

            if index < pokemon_count {
                species_vec[index] = Some(species_data);
            } else {
                eprintln!(
                    "cargo:warning=Pokémon '{}' has a Pokedex number ({}) that is out of bounds for the detected count of {}. It will be ignored.",
                    species_data.name, species_data.pokedex_number, pokemon_count
                );
            }
        }
    }

    // Serialize the Vec to a postcard binary file
    let postcard_bytes = postcard::to_allocvec(&species_vec)?;
    let dest_path = Path::new(out_dir).join("compiled_species.postcard");
    fs::write(dest_path, postcard_bytes)?;

    // Write the Rust function that will load the bytes into a static slice
    writeln!(
        f,
        "pub fn get_compiled_species_data() -> &'static [Option<schema::PokemonSpecies>] {{"
    )?;
    writeln!(f, "    let bytes = include_bytes!(concat!(env!(\"OUT_DIR\"), \"/compiled_species.postcard\"));")?;
    // This pattern deserializes into an owned Box, then "leaks" it to get a 'static reference.
    // This is the standard, safe way to initialize static data from bytes.
    writeln!(f, "    let boxed_slice: Box<[Option<schema::PokemonSpecies>]> = postcard::from_bytes(bytes).expect(\"Failed to deserialize species data\");")?;
    writeln!(f, "    Box::leak(boxed_slice)")?;
    writeln!(f, "}}")?;
    writeln!(f)?;
    Ok(())
}

/// Parses team .ron files recursively, serializes them to a postcard binary file,
/// and writes a Rust function that loads this data as a static HashMap.
fn generate_team_data(out_dir: &str, f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=data/teams");

    // First, we need to write the data structures
    writeln!(f, "// Team data structures")?;
    writeln!(
        f,
        "#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]"
    )?;
    writeln!(f, "pub struct PokemonTemplate {{")?;
    writeln!(f, "    pub species: schema::Species,")?;
    writeln!(f, "    pub level: u8,")?;
    writeln!(f, "    pub moves: Option<Vec<schema::Move>>,")?;
    writeln!(f, "}}")?;
    writeln!(f)?;

    writeln!(
        f,
        "#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]"
    )?;
    writeln!(f, "pub struct TeamTemplate {{")?;
    writeln!(f, "    pub id: String,")?;
    writeln!(f, "    pub name: String,")?;
    writeln!(f, "    pub description: String,")?;
    writeln!(f, "    pub pokemon: Vec<PokemonTemplate>,")?;
    writeln!(f, "}}")?;
    writeln!(f)?;

    let data_path = Path::new("data/teams");
    let mut teams_map = HashMap::<String, TeamTemplate>::new();

    // Recursively process team files
    collect_team_files(&data_path, &mut teams_map)?;

    // Serialize the entire map to a binary file
    let postcard_bytes = postcard::to_allocvec(&teams_map)?;
    let dest_path = Path::new(out_dir).join("compiled_teams.postcard");
    fs::write(dest_path, postcard_bytes)?;

    // Write the Rust function that will load these bytes at compile time
    writeln!(
        f,
        "pub fn get_compiled_team_data() -> std::collections::HashMap<String, TeamTemplate> {{"
    )?;
    writeln!(
        f,
        "    let bytes = include_bytes!(concat!(env!(\"OUT_DIR\"), \"/compiled_teams.postcard\"));"
    )?;
    writeln!(
        f,
        "    postcard::from_bytes(bytes).expect(\"Failed to deserialize team data\")"
    )?;
    writeln!(f, "}}")?;
    writeln!(f)?;

    Ok(())
}

/// Recursively collect team files from directories
fn collect_team_files(
    dir: &Path,
    teams_map: &mut HashMap<String, TeamTemplate>,
) -> Result<(), Box<dyn std::error::Error>> {
    for entry in fs::read_dir(dir)? {
        let path = entry?.path();
        if path.is_dir() {
            // Recursively process subdirectories
            collect_team_files(&path, teams_map)?;
        } else if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;
            let team_data: TeamTemplate = ron::from_str(&content)
                .map_err(|e| format!("Failed to parse team file {:?}: {}", path, e))?;

            // Use the team's id as the key
            let team_id = team_data.id.clone();
            teams_map.insert(team_id, team_data);
        }
    }
    Ok(())
}
