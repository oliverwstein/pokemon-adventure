// In: build.rs

use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

// Your build script now depends on the schema crate, ron, and postcard.
use schema::{Move, MoveData, PokemonSpecies};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // --- Setup ---
    println!("cargo:rerun-if-changed=data");
    let out_dir = env::var("OUT_DIR").unwrap();
    let generated_code_path = Path::new(&out_dir).join("generated_data.rs");
    let mut code_file = fs::File::create(&generated_code_path)?;

    // --- File Header ---
    writeln!(
        code_file,
        "// This file is generated by build.rs - do not edit manually."
    )?;
    writeln!(
        code_file,
        "// It contains functions to load compile-time data from binary files."
    )?;
    writeln!(code_file)?;

    // --- Data Generation ---
    generate_move_data(&out_dir, &mut code_file)?;
    generate_species_data(&out_dir, &mut code_file)?;
    // We'll keep prefab_teams as-is for now, as it's not a performance bottleneck.
    generate_prefab_teams_data(&mut code_file)?;

    println!(
        "Generated postcard data and loader functions at: {}",
        out_dir
    );
    Ok(())
}

/// Parses move .ron files, serializes them to a postcard binary file,
/// and writes a Rust function that loads this data as a static HashMap.
fn generate_move_data(out_dir: &str, f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=data/moves");
    let data_path = Path::new("data/moves");
    let mut moves_map = HashMap::<Move, MoveData>::new();

    for entry in fs::read_dir(data_path)? {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;
            let move_data: MoveData = ron::from_str(&content)
                .map_err(|e| format!("Failed to parse {:?}: {}", path, e))?;
            // Robustly parse the move name from the data to get the enum variant
            let move_enum_variant: Move = move_data.name.parse().map_err(|e| {
                format!(
                    "Failed to parse move name '{}' in {:?}: {}",
                    move_data.name, path, e
                )
            })?;
            moves_map.insert(move_enum_variant, move_data);
        }
    }

    // Serialize the entire map to a binary file
    let postcard_bytes = postcard::to_allocvec(&moves_map)?;
    let dest_path = Path::new(out_dir).join("compiled_moves.postcard");
    fs::write(dest_path, postcard_bytes)?;

    // Write the Rust function that will load these bytes at compile time
    writeln!(f, "pub fn get_compiled_move_data() -> std::collections::HashMap<schema::Move, schema::MoveData> {{")?;
    writeln!(
        f,
        "    let bytes = include_bytes!(concat!(env!(\"OUT_DIR\"), \"/compiled_moves.postcard\"));"
    )?;
    writeln!(
        f,
        "    postcard::from_bytes(bytes).expect(\"Failed to deserialize move data\")"
    )?;
    writeln!(f, "}}")?;
    writeln!(f)?;
    Ok(())
}

/// Parses species .ron files, serializes them to a postcard binary file,
/// and writes a Rust function that loads this data as a static slice.
fn generate_species_data(
    out_dir: &str,
    f: &mut fs::File,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=data/pokemon");
    let data_path = Path::new("data/pokemon");

    // Dynamically count the number of valid Pokémon .ron files
    let pokemon_count = fs::read_dir(data_path)?
        .filter_map(Result::ok)
        .filter(|entry| entry.path().extension().and_then(|s| s.to_str()) == Some("ron"))
        .count();

    if pokemon_count == 0 {
        writeln!(f, "// No Pokémon data found, generating an empty slice.")?;
        writeln!(
            f,
            "pub fn get_compiled_species_data() -> &'static [Option<schema::PokemonSpecies>] {{"
        )?;
        writeln!(f, "    &[]")?;
        writeln!(f, "}}")?;
        return Ok(());
    }

    // Use a Vec for easier, safer initialization based on the dynamic count
    let mut species_vec: Vec<Option<PokemonSpecies>> = vec![None; pokemon_count];

    for entry in fs::read_dir(data_path)? {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;
            let species_data: PokemonSpecies = ron::from_str(&content)
                .map_err(|e| format!("Failed to parse {:?}: {}", path, e))?;
            let index = species_data.pokedex_number as usize - 1;

            if index < pokemon_count {
                species_vec[index] = Some(species_data);
            } else {
                eprintln!(
                    "cargo:warning=Pokémon '{}' has a Pokedex number ({}) that is out of bounds for the detected count of {}. It will be ignored.",
                    species_data.name, species_data.pokedex_number, pokemon_count
                );
            }
        }
    }

    // Serialize the Vec to a postcard binary file
    let postcard_bytes = postcard::to_allocvec(&species_vec)?;
    let dest_path = Path::new(out_dir).join("compiled_species.postcard");
    fs::write(dest_path, postcard_bytes)?;

    // Write the Rust function that will load the bytes into a static slice
    writeln!(
        f,
        "pub fn get_compiled_species_data() -> &'static [Option<schema::PokemonSpecies>] {{"
    )?;
    writeln!(f, "    let bytes = include_bytes!(concat!(env!(\"OUT_DIR\"), \"/compiled_species.postcard\"));")?;
    // This pattern deserializes into an owned Box, then "leaks" it to get a 'static reference.
    // This is the standard, safe way to initialize static data from bytes.
    writeln!(f, "    let boxed_slice: Box<[Option<schema::PokemonSpecies>]> = postcard::from_bytes(bytes).expect(\"Failed to deserialize species data\");")?;
    writeln!(f, "    Box::leak(boxed_slice)")?;
    writeln!(f, "}}")?;
    writeln!(f)?;
    Ok(())
}

/// This function remains unchanged as it handles non-performance-critical data.
fn generate_prefab_teams_data(f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=data/prefab_teams");
    let data_path = Path::new("data/prefab_teams");
    let mut teams = Vec::new();

    if data_path.exists() {
        for entry in fs::read_dir(data_path)? {
            let path = entry?.path();
            if path.extension().and_then(|s| s.to_str()) == Some("ron") {
                let content = fs::read_to_string(&path)?;
                let team_name = path.file_stem().unwrap().to_str().unwrap();
                teams.push((team_name.to_string(), content));
            }
        }
    }
    teams.sort_by(|a, b| a.0.cmp(&b.0));

    writeln!(f, "pub fn get_compiled_prefab_teams() -> std::collections::HashMap<&'static str, &'static str> {{")?;
    writeln!(f, "    let map = std::collections::HashMap::new();")?;
    for (team_name, ron_content) in teams {
        writeln!(
            f,
            "    map.insert(\"{}\", r####\"{}\"####);",
            team_name, ron_content
        )?;
    }
    writeln!(f, "    map")?;
    writeln!(f, "}}")?;
    Ok(())
}
