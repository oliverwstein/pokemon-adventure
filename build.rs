use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=data");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_data.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // Generate the file header
    writeln!(
        f,
        "// This file is generated by build.rs - do not edit manually"
    )
    .unwrap();
    writeln!(f, "").unwrap();

    // Generate move data
    generate_move_data(&mut f).unwrap();

    // Generate species data
    generate_species_data(&mut f).unwrap();

    // Generate prefab teams data
    generate_prefab_teams_data(&mut f).unwrap();

    println!("Generated data at: {}", dest_path.display());
}

fn generate_move_data(f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    let data_path = Path::new("data/moves");
    let mut moves = Vec::new();

    println!("Generating move data...");

    for entry in fs::read_dir(data_path)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;

            // Parse the RON to extract the name field using a simpler approach
            // Look for the name field in the content string directly
            if let Some(name_start) = content.find("name: \"") {
                let name_start = name_start + 7; // Skip 'name: "'
                if let Some(name_end) = content[name_start..].find('"') {
                    let name = &content[name_start..name_start + name_end];
                    // Convert name to enum variant by removing whitespace and special characters
                    let move_variant = name.replace([' ', '-', '\'', '.'], "");
                    moves.push((move_variant, content));
                }
            }
        }
    }

    // Sort for consistent generation
    moves.sort_by(|a, b| a.0.cmp(&b.0));

    writeln!(
        f,
        "pub fn get_compiled_move_data() -> std::collections::HashMap<crate::moves::Move, crate::move_data::MoveData> {{"
    )?;
    writeln!(f, "    let mut map = std::collections::HashMap::new();")?;

    for (move_variant, ron_content) in moves {
        // Use raw string literal with a unique delimiter to avoid conflicts
        writeln!(
            f,
            "    map.insert(crate::moves::Move::{}, ron::from_str(r####\"{}\"####).unwrap());",
            move_variant, ron_content
        )?;
    }

    writeln!(f, "    map")?;
    writeln!(f, "}}")?;
    writeln!(f, "")?;

    Ok(())
}

fn generate_species_data(f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    let data_path = Path::new("data/pokemon");
    let mut species = Vec::new();

    println!("Generating species data...");

    for entry in fs::read_dir(data_path)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("ron") {
            let content = fs::read_to_string(&path)?;
            let filename = path.file_stem().unwrap().to_str().unwrap();

            // Extract species from filename (e.g., "001-bulbasaur" -> "Bulbasaur")
            if let Some((_, species_name)) = filename.split_once('-') {
                let species_variant = filename_to_species_variant(species_name);
                species.push((species_variant, content));
            }
        }
    }

    // Sort by species enum for consistent generation
    species.sort_by(|a, b| a.0.cmp(&b.0));

    writeln!(
        f,
        "pub fn get_compiled_species_data() -> [Option<crate::pokemon::PokemonSpecies>; 151] {{"
    )?;
    writeln!(f, "    let mut data = [const {{ None }}; 151];")?;

    for (species_variant, ron_content) in species {
        writeln!(
            f,
            "    data[crate::species::Species::{}.pokedex_number() as usize - 1] = Some(ron::from_str(r####\"{}\"####).unwrap());",
            species_variant, ron_content
        )?;
    }

    writeln!(f, "    data")?;
    writeln!(f, "}}")?;
    writeln!(f, "")?;

    Ok(())
}

fn generate_prefab_teams_data(f: &mut fs::File) -> Result<(), Box<dyn std::error::Error>> {
    let data_path = Path::new("data/prefab_teams");
    let mut teams = Vec::new();

    println!("Generating prefab teams data...");

    if data_path.exists() {
        for entry in fs::read_dir(data_path)? {
            let entry = entry?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("ron") {
                let content = fs::read_to_string(&path)?;
                let team_name = path.file_stem().unwrap().to_str().unwrap();

                teams.push((team_name.to_string(), content));
            }
        }
    }

    // Sort for consistent generation
    teams.sort_by(|a, b| a.0.cmp(&b.0));

    writeln!(
        f,
        "pub fn get_compiled_prefab_teams() -> std::collections::HashMap<&'static str, &'static str> {{"
    )?;
    writeln!(f, "    let mut map = std::collections::HashMap::new();")?;

    for (team_name, ron_content) in teams {
        writeln!(
            f,
            "    map.insert(\"{}\", r####\"{}\"####);",
            team_name, ron_content
        )?;
    }

    writeln!(f, "    map")?;
    writeln!(f, "}}")?;

    Ok(())
}

/// Convert filename to Species enum variant  
/// e.g., "bulbasaur" -> "Bulbasaur", "mr_mime" -> "MrMime"
fn filename_to_species_variant(filename: &str) -> String {
    match filename {
        "mr_mime" => "MrMime".to_string(),
        "farfetchd" => "Farfetchd".to_string(),
        "nidoran_f" => "NidoranFemale".to_string(),
        "nidoran_m" => "NidoranMale".to_string(),
        name => {
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        }
    }
}
